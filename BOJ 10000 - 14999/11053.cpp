// BOJ - 11053

#include <stdio.h>
int max(int a,int b)
{
	return a>b?a:b;
}
int main()
{
	int n;
	scanf("%d",&n);
	int D[n+1]={0},O[n+1]={0};
	// D[i] = "O[1] ~ O[i] 까지 가장 긴 증가하는 부분 수열의 길이"
	// D[1] 는 당연히 O[1] 하나의 길이이므로 D[1]=1 이다. 
	D[1]=1;
	for(int i=1; i<=n; i++)
		scanf("%d",&O[i]);
	// 10 20 11 12 를 예로 들어보자.
	// 10 20 도 증가하는 부분 수열이 될 수 있지만
	// 10 11 12 가 더 크다. 하지만, 11을 탐색할 때, 10을 탐색해야하므로
	// 이전 수만 생각하기에는 어려움이 많다.
	// 그러므로 i 구간을 탐색할 때는 1부터 i까지 탐색한다.
	// 물론, 그렇게 효율적이지는 못할 수는 있다.
	// 하지만 이 문제에서는 수열 A의 크기가 1000이므로 시간 복잡도를 따졌을 때
	// 풀기에는 어려움이 있어 보이지는 않는다. 
	int ans=D[1];
	for(int i=2; i<=n; i++)
	{
		int temp=1;
		for(int j=1; j<i; j++)
			if(O[j]<O[i])
				temp=max(temp,D[j]+1);
		D[i]=temp;
		ans=max(ans,temp);
	}
	/*
	항상 D[k]의 최댓값이 N 번째에서 끝난다는 보장이 없으므로, D[1]~D[N] 에서
	최댓값을 찾아야한다. 
	*/
	printf("%d",ans);
}
