// BOJ - 2718 ( 2 tries )

/*
이 문제는 고민 끝에 '자연수의 분할' 을 이용해 문제를 해결하였다.
f(n)="4*n 을 2*1 또는 1*2 로 채우는 경우의 수"
g(n)="4*n 을 2*1 또는 1*2 로 채우는 4의 길이로 분할할 수 없는 경우의 수"
예를 들어서,
 3
=3
=1 + 2
=2 + 1
=1 + 1 + 1 

일단 기본적으로, 2*1 또는 1*2 로 채울 수 있는 크기는 2K 이다. 
즉, 4*n ( n는 양수 ) 라 하였을 때, 못 채우는 경우의 수는 없다.

자연수의 분할 의미는 1+2 라면, 4*1 와 4*2 를 채우는 경우의 수를 곱하면 된다.
단, 4*2는 4*1와 4*1로 쪼갤 수 있게 된다면, 1+1+1 와 다를 바가 없어지게 된다.
그러므로, g(n)를 사용한 것이다. g(2)는 4이다.

g(n)을 몇개만 나열해보면 g(1) , g(2) 는 예외처리하고, n이 짝수인지 홀수인지에 따라서 값이 나온다.

자, 다시 보겠다.
 3
=3
=(1) + 2
=(2) + 1
=(1 + 1) + 1  

f(n) 과 g(n) 의 세워둔 정의를 다시 보자. g(n)의 값이 f(n)에 포함되어있다는 것을 알 수 있게 된다. 

저기 위에 가로친 부분을 예로 들면 (2) + 1 와 (1 + 1) + 1는 결국 f(2) * g(1) 라는 것을 이해할 수 있게 된다.
결국, 정리해보자면, f(n)은 g(i)*f(n-i) (i=[1,n]) 이다. f(0)은 1로 정해두면 편하다.

그걸 구현한 것이다.

최대한 간결하게 정리를 해보았다. 
*/

#include <stdio.h>

#define MAX 100

int g(int q)
{
	if(q==1) return 1;
	else if(q==2) return 4;
	else if(q%2) return 2;
	else return 3;
}
int main()
{
	int T,f[MAX+1]={1},n;
	scanf("%d",&T);
	f[1]=1,f[2]=5;
	for(int i=3; i<=MAX; i++)
	{
		int val=0;
		for(int j=1; j<=i; j++)
			val+=(g(j)*f[i-j]);
		f[i]=val;
	}
	while(T--)
	{
		scanf("%d",&n);
		printf("%d\n",f[n]);
	}
}
